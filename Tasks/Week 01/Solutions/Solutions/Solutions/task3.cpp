/**
	Направете програма, която по подадени радиус и височина на конус, да намери обема (V), 
	лицето на околната повърхнина (L), лицето на основата (B) и общото лице (A). Закръглете 
	стойностите нагоре до втория знак след запетаята. Резултата да се изпише на екрана хубаво и чистичко.
*/

#include <iostream>
#include <cmath>

using namespace std;

int main() {
	/**
		Променливите, които ще използваме за входа от условието
	*/
	double r, h;

	/**
		Променливите, които ще използваме да си помним резултата от сметките за обема и т.н.
	*/
	double V, //Volume - обем 
		   L, //Lateral surface - околна повърхнина
		   B, //Base surface - Лице на основата
		   A, //Обща повърхнина
		   s; //Slant height - образуваща на конуса

	/**
		Ще използваме малко обратни тригонометрични функции от <cmath>, за да получим числото Пи. Правим го константа,
		защото няма какво да го променяме като стойност в бъдеще. За контролни и изпити, разбира се не е нужно да го
		изчислявате, а може просто да го хардкоднете, но пък така е по-готино :D
	*/
	const double PI = 2 * acos(0.0);

	cout << "Enter radius: ";
	cin >> r;

	cout << "Enter height: ";
	cin >> h;

	/**
		Сега спрямо смятане на лице на правоъгълник, писането на формулата на обем е една идея по сложно поради няколко причини:
			* Първо има значение къде ще слагате скоби, за да обособявате изрази. В C++ 1/3.0*p и (1/3.0)*p са два съвсем различни
			  израза. В първия случай ще умножим 3.0 с p и след това ще разделим единицата, а във втория ще получим 1/3.0 и тогава
			  ще умножим с p. Ако не сте сигурни коя операция ще се изпълни преди друга то обособявайте със скоби съответните изрази,
			  които искате да се изчислят преди други.
			* Второ повечето от вас директно пишат 1/3 и после има "Ама защо е 0". Е ми отговора е защото компилатора е прост и не знае
			  какво искате от него точно. В c++ ако при използване на оператор за целочислено делене / и двата операнда са цели числа
			  то ще върне цялата част от делението. Например 25/4 = 6, защото 25 = 4*6 + 1, едно в случая е остатъка от делението, а 6
			  е цялата част. Поради тази причина трябва да подскажете на компилатора, че не искате целочислен резултата, а "реален". 
			  За това единия операнд трябва да е float/double. Това става като:
				* Ако операнда е литерал то го пишете с точка последвано от нула. Това за компилатора е float/double. Както в примера 
				  3 е написано като 3.0
				* Ако операнда е израз то трябва да го cast-нете, което значи да укажете на компилатора в какво да го превърне. Това
			      става като напишете типа към, който искате да кастнете във скоби пред операнда. Например 1/(double)3 == 1/3.0

			pow е функция от <cmath>, която вдига на степен първия параметър, в случая r, на степен втория параметър, в случая 2
	*/
	V = (1 / 3.0) * PI * pow(r, 2) * h;

	//sqrt връща корен квадратен от подадената стойност
	s = sqrt(pow(r, 2) + pow(h, 2));

	L = PI * r * s;

	//Другия вариант за вдигане на степен е да напишете няколко пъти стойността и да използвате оператор *
	//Но ако се налага да го вдигнете на степен 100 идва малко по-сложно да го хардкоднете
	B = PI * r * r;

	A = L + B;

	/**
		Сега закръглянето се оказа по-трудоемка задача от очакването. В <cmath> има функции, които закръглят дадено число, но до цяло такова,
		а не до някой определен знак. За това трябва да направим първо няколко трика за да постигнем желания ефект:
			Нека за пример вземе числото 12.345. Това по условие трябва да се закръгли до 12.35. За това ще направим следното:
			* Първо умножаваме числото по 100 - това ни дава 1234.5
			* Сега това число можем да го закръглим нагоре като добавим 0.5 и го кастнем към int 1234.5 + 0.5 = 1235.0 ->(int)1235.0 =1235
			* И накрая просто го делим на 100.0 (пак обръщаме внимание, че трябва единият операнд да е "реално число")
	*/

	V = ((int)(V * 100 + 0.5)) / 100.0;
	L = ((int)(L * 100 + 0.5)) / 100.0;
	B = ((int)(B * 100 + 0.5)) / 100.0;
	A = ((int)(A * 100 + 0.5)) / 100.0;

	/**
		Ако забелязвате горните три реда са дни и същи като сметки и логика, но само използваме различни обекти. Решение на този проблем ще видим
		по-късно като се запознаем с функции, за да не копираме един и същ код и да заместваме като идиоти букивчки.
	*/


	/**
		Сега изпиването до втория знак можем да използваме setprecision() (можете да разберете повече за него в гугъл), но понеже от предишните
		сметки вече ще има макс 2 знака след запетаята може да го пропуснем. Принципно на контролни и изпити не ви караме да форматирате толкова
		прецизно нещата, но да го имате в предвид ако искате да го използвате. !!setprecision не закръглява, а само указва на конзолата до кой
		знак да принтира!!
	*/
	cout << "V = " << V
		<< "\nL = " << L
		<< "\nB = " << B
		<< "\nA = " << A << endl;

}